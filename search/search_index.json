{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Saffy A High-Level Signal Analysis Framework Ever too often in signal analysis is time wasted on the repetitive tasks, which are very similar across projects. You promise yourself to build a code base for your solutions, but end up just copy pasting whole chunks of code. Starting each project you hope that this time you will have good structure and it will be awesome to work with. But it most often fails. Probably because your on a deadline or building sustainable data architectures is not your thing, you just wanted to do some analysis. Rightfully so! That's why saffy was created, so that you don't have to come up with a data structure and architecture. So that you can concentrate on the fun and important part which is the analysis! When you come up with a solution you like, you already have it as part of the framework, so it is easy to use in the future. Features Write 50% less code than before You concentrate on the fun logic stuff and let saffy do the boring repetetive tasks. Lost in variables and data? Saffy provides a data architecture to keep it clean. Quick prototyping of signal analysis algorithms Reproducibility of solutions Clean, readable and organized code Your code-base can easily expand over multiple projects A clean pipline from modeled signals to real-world data Less simple and repetitive work Install pip3 install saffy From Source Using a virtualenv is recommended! !pip3 install -U https://api.github.com/repos/saffy-team/saffy/zipball/master or if you want the source code Download the package to your project directory git clone https://github.com/saffy-team/saffy.git Install dependencies pip3 install -r ./saffy/requirements.txt Usage import saffy sig = saffy.SignalManager(filename=\"path/to/file\") Example A short example of how to use saffy for EEG data analysis. EEG = saffy.SignalManager(filename=\"path/to/file\") EEG.extract_channels(['C3', 'C4', 'trig']) EEG.set_tags_from_channel('trig') EEG.remove_channel('trig') EEG.butter_highpass_filter(cutoff=1, order=2) EEG.cheb2_notch_filter(cutoff=50, order=1, rs=3, width=0.3, btype='bandstop') PRE_EEG = EEG.copy('pre') PRE_EEG.set_epochs_from_tags(-4, -2) PRE_EEG.welch_mean_spectrum() POST_EEG = EEG.copy('post') POST_EEG.set_epochs_from_tags(0.5, 2.5) POST_EEG.welch_mean_spectrum() With just this code we managed to calculate the mean spectrum using Welch's method for the signal before and after the trigger. In plain numpy and scipy this would take much longer, would be less readable and probably would be much more error prone. For comparison you can see the attached solution in plain numpy and scipy. Contributing If you like the project and want to add something to it then please create a pull request. - The title should shortly summarize the goal of your addition - In the description go in depth with the changes you have made and why.","title":"Home"},{"location":"#saffy","text":"","title":"Saffy"},{"location":"#a-high-level-signal-analysis-framework","text":"Ever too often in signal analysis is time wasted on the repetitive tasks, which are very similar across projects. You promise yourself to build a code base for your solutions, but end up just copy pasting whole chunks of code. Starting each project you hope that this time you will have good structure and it will be awesome to work with. But it most often fails. Probably because your on a deadline or building sustainable data architectures is not your thing, you just wanted to do some analysis. Rightfully so! That's why saffy was created, so that you don't have to come up with a data structure and architecture. So that you can concentrate on the fun and important part which is the analysis! When you come up with a solution you like, you already have it as part of the framework, so it is easy to use in the future.","title":"A High-Level Signal Analysis Framework"},{"location":"#features","text":"Write 50% less code than before You concentrate on the fun logic stuff and let saffy do the boring repetetive tasks. Lost in variables and data? Saffy provides a data architecture to keep it clean. Quick prototyping of signal analysis algorithms Reproducibility of solutions Clean, readable and organized code Your code-base can easily expand over multiple projects A clean pipline from modeled signals to real-world data Less simple and repetitive work","title":"Features"},{"location":"#install","text":"pip3 install saffy","title":"Install"},{"location":"#from-source","text":"Using a virtualenv is recommended! !pip3 install -U https://api.github.com/repos/saffy-team/saffy/zipball/master or if you want the source code Download the package to your project directory git clone https://github.com/saffy-team/saffy.git Install dependencies pip3 install -r ./saffy/requirements.txt","title":"From Source"},{"location":"#usage","text":"import saffy sig = saffy.SignalManager(filename=\"path/to/file\")","title":"Usage"},{"location":"#example","text":"A short example of how to use saffy for EEG data analysis. EEG = saffy.SignalManager(filename=\"path/to/file\") EEG.extract_channels(['C3', 'C4', 'trig']) EEG.set_tags_from_channel('trig') EEG.remove_channel('trig') EEG.butter_highpass_filter(cutoff=1, order=2) EEG.cheb2_notch_filter(cutoff=50, order=1, rs=3, width=0.3, btype='bandstop') PRE_EEG = EEG.copy('pre') PRE_EEG.set_epochs_from_tags(-4, -2) PRE_EEG.welch_mean_spectrum() POST_EEG = EEG.copy('post') POST_EEG.set_epochs_from_tags(0.5, 2.5) POST_EEG.welch_mean_spectrum() With just this code we managed to calculate the mean spectrum using Welch's method for the signal before and after the trigger. In plain numpy and scipy this would take much longer, would be less readable and probably would be much more error prone. For comparison you can see the attached solution in plain numpy and scipy.","title":"Example"},{"location":"#contributing","text":"If you like the project and want to add something to it then please create a pull request. - The title should shortly summarize the goal of your addition - In the description go in depth with the changes you have made and why.","title":"Contributing"},{"location":"SignalManager/","text":"SignalManager The SignalManager comes with some basic parameters. field description fs sampling frequency num_channels number of channels channel_names name for each channel data the signal in the structure of (epoch x channel x signal) t time vector epochs number of epochs tags position of tags in signal spectrum matrix of spectrum spectrum_freqs vector of frequencies phase matrix of phase history a list of all the steps taken When initializing the object there are two options. Generator A dictionary of the structure data = { 'fs': # float, 'num_channels': # integer, 'channel_names': # list of strings, 'epochs': # integer, 't': # time array, 'tags': # list, 'data': # Signal Matrix } saffy.SignalManager(generator=data) Filename The name of the file generated by Svarog. 3 files eg. data.raw , data.xml , data.tag saffy.SignalManager(filename='data') set_tags_from_channel(self, channel_name) Uses a channel as the tag indicator. Normalizes the value to 1 through divided by the maximum value. Sets threshold at 0.9. Sets tag at beginnings of resultant clusters. set_epochs_from_tags(self, low, high) Uses the tag list to cut the data into epochs. The low and high tell us where to cut based on the tags. They are in seconds. For example if you want to cut between 2 seconds before and 3 after the tag you would write sig.set_epochs_from_tags(-2, 3) . remove_channels(self, channel_names) Removes the specified channels from the data. Params channel_names: list of strings extract_channels(self, channel_names) Removes all channels except for those provided in the `channel_names' parameter. Params channel_names: list of strings extract_time_range(self, low, high) Cuts data to the provided low and high arguments. Params low: starting point of new signal in seconds. high: end point of new signal in seconds. copy(self, name=\"\") Creates a independent copy of the SignalManager object. Params name: a documenting value to keep track why we are coping the signal. call(self, func) Used to run single custom functions on the data. Allows consistency when building analysis piplines. Params func: a function that takes only self as the parameter. Example You should do this: def custom_function(self): print(self.data) sig.call(custom_function) instead of this: def custom_function(sig): print(sig.data) custom_function(sig) register_plugin(cls, plugin) Use this to add a custom plugin to be used with the SignalManager Params plugin: An instance of the PluginManager class. Example Create a custom plugin. class CustomPlugin(saffy.PluginManager): def __init__(self, *args, **kwargs): super().__init__(*args, **kwargs) self.custom = { 'param': 'some value' } def custom_function(self): # do something pass Then you can regiser it and use the custom_function . saffy.SignalManager.register_plugin(CustomPlugin) History All the operations on the signal are stored in the history parameter. It allows to keep track of the changes that have been made to the signal.","title":"SignalManager"},{"location":"SignalManager/#signalmanager","text":"The SignalManager comes with some basic parameters. field description fs sampling frequency num_channels number of channels channel_names name for each channel data the signal in the structure of (epoch x channel x signal) t time vector epochs number of epochs tags position of tags in signal spectrum matrix of spectrum spectrum_freqs vector of frequencies phase matrix of phase history a list of all the steps taken When initializing the object there are two options.","title":"SignalManager"},{"location":"SignalManager/#generator","text":"A dictionary of the structure data = { 'fs': # float, 'num_channels': # integer, 'channel_names': # list of strings, 'epochs': # integer, 't': # time array, 'tags': # list, 'data': # Signal Matrix } saffy.SignalManager(generator=data)","title":"Generator"},{"location":"SignalManager/#filename","text":"The name of the file generated by Svarog. 3 files eg. data.raw , data.xml , data.tag saffy.SignalManager(filename='data')","title":"Filename"},{"location":"SignalManager/#set_tags_from_channelself-channel_name","text":"Uses a channel as the tag indicator. Normalizes the value to 1 through divided by the maximum value. Sets threshold at 0.9. Sets tag at beginnings of resultant clusters.","title":"set_tags_from_channel(self, channel_name)"},{"location":"SignalManager/#set_epochs_from_tagsself-low-high","text":"Uses the tag list to cut the data into epochs. The low and high tell us where to cut based on the tags. They are in seconds. For example if you want to cut between 2 seconds before and 3 after the tag you would write sig.set_epochs_from_tags(-2, 3) .","title":"set_epochs_from_tags(self, low, high)"},{"location":"SignalManager/#remove_channelsself-channel_names","text":"Removes the specified channels from the data.","title":"remove_channels(self, channel_names)"},{"location":"SignalManager/#params","text":"channel_names: list of strings","title":"Params"},{"location":"SignalManager/#extract_channelsself-channel_names","text":"Removes all channels except for those provided in the `channel_names' parameter.","title":"extract_channels(self, channel_names)"},{"location":"SignalManager/#params_1","text":"channel_names: list of strings","title":"Params"},{"location":"SignalManager/#extract_time_rangeself-low-high","text":"Cuts data to the provided low and high arguments.","title":"extract_time_range(self, low, high)"},{"location":"SignalManager/#params_2","text":"low: starting point of new signal in seconds. high: end point of new signal in seconds.","title":"Params"},{"location":"SignalManager/#copyself-name","text":"Creates a independent copy of the SignalManager object.","title":"copy(self, name=\"\")"},{"location":"SignalManager/#params_3","text":"name: a documenting value to keep track why we are coping the signal.","title":"Params"},{"location":"SignalManager/#callself-func","text":"Used to run single custom functions on the data. Allows consistency when building analysis piplines.","title":"call(self, func)"},{"location":"SignalManager/#params_4","text":"func: a function that takes only self as the parameter.","title":"Params"},{"location":"SignalManager/#example","text":"You should do this: def custom_function(self): print(self.data) sig.call(custom_function) instead of this: def custom_function(sig): print(sig.data) custom_function(sig)","title":"Example"},{"location":"SignalManager/#register_plugincls-plugin","text":"Use this to add a custom plugin to be used with the SignalManager","title":"register_plugin(cls, plugin)"},{"location":"SignalManager/#params_5","text":"plugin: An instance of the PluginManager class.","title":"Params"},{"location":"SignalManager/#example_1","text":"Create a custom plugin. class CustomPlugin(saffy.PluginManager): def __init__(self, *args, **kwargs): super().__init__(*args, **kwargs) self.custom = { 'param': 'some value' } def custom_function(self): # do something pass Then you can regiser it and use the custom_function . saffy.SignalManager.register_plugin(CustomPlugin)","title":"Example"},{"location":"SignalManager/#history","text":"All the operations on the signal are stored in the history parameter. It allows to keep track of the changes that have been made to the signal.","title":"History"},{"location":"Plugins/Create Custom Plugin/","text":"Create Custom Plugin There will most definitely be a case, where you will want to create a custom plugin. The proposed convention for plugin development is the following. All data that is to be stored extra, should be stored in the form of a dictionary assigned to a variable of the same name as the plugin. Plugin functions should be preceded by the plugin name. Class Implementation import saffy class CustomPlugin(saffy.PluginManager): def __init__(self, *args, **kwargs): super().__init__(*args, **kwargs) self.custom = { 'param': 'some value' } def custom_function(self): # do something pass saffy.SignalManager.register_plugin(CustomPlugin) sig = saffy.SignalManager(generator=signal_data) sig.custom_function() Functional Plugin In other cases when it is only one function you want to use you can use the call function sig = saffy.SignalManager(generator=signal_data) def custom_function(self): print(self.data) sig.call(custom_function)","title":"Create Custom Plugin"},{"location":"Plugins/Create Custom Plugin/#create-custom-plugin","text":"There will most definitely be a case, where you will want to create a custom plugin. The proposed convention for plugin development is the following. All data that is to be stored extra, should be stored in the form of a dictionary assigned to a variable of the same name as the plugin. Plugin functions should be preceded by the plugin name.","title":"Create Custom Plugin"},{"location":"Plugins/Create Custom Plugin/#class-implementation","text":"import saffy class CustomPlugin(saffy.PluginManager): def __init__(self, *args, **kwargs): super().__init__(*args, **kwargs) self.custom = { 'param': 'some value' } def custom_function(self): # do something pass saffy.SignalManager.register_plugin(CustomPlugin) sig = saffy.SignalManager(generator=signal_data) sig.custom_function()","title":"Class Implementation"},{"location":"Plugins/Create Custom Plugin/#functional-plugin","text":"In other cases when it is only one function you want to use you can use the call function sig = saffy.SignalManager(generator=signal_data) def custom_function(self): print(self.data) sig.call(custom_function)","title":"Functional Plugin"},{"location":"Plugins/Hilbert/","text":"Hilbert The plugin for calculating Hilbert Transform hilbert: dict The data structure which stores all the calculated values, like the power, amplitude, phase. \"data\": hilbert transform, \"amplitude\": the instantaneous amplitude, \"power\": the instantaneous power, \"phase\": the instantaneous phase hilbert_transform(self, phase_freq=0) Calculates the Hilbert Transform. The phase_freq is used to determine for which frequency is the instantaneous phase to be calculated. It populates all the values of the hilbert dictionary. hilbert_subtract_base(self, low, high) Subtracts the mean of the power between the low high params from the power. hilbert_mean_power(self) Calculates the mean power across epochs.","title":"Hilbert"},{"location":"Plugins/Hilbert/#hilbert","text":"The plugin for calculating Hilbert Transform","title":"Hilbert"},{"location":"Plugins/Hilbert/#hilbert-dict","text":"The data structure which stores all the calculated values, like the power, amplitude, phase. \"data\": hilbert transform, \"amplitude\": the instantaneous amplitude, \"power\": the instantaneous power, \"phase\": the instantaneous phase","title":"hilbert: dict"},{"location":"Plugins/Hilbert/#hilbert_transformself-phase_freq0","text":"Calculates the Hilbert Transform. The phase_freq is used to determine for which frequency is the instantaneous phase to be calculated. It populates all the values of the hilbert dictionary.","title":"hilbert_transform(self, phase_freq=0)"},{"location":"Plugins/Hilbert/#hilbert_subtract_baseself-low-high","text":"Subtracts the mean of the power between the low high params from the power.","title":"hilbert_subtract_base(self, low, high)"},{"location":"Plugins/Hilbert/#hilbert_mean_powerself","text":"Calculates the mean power across epochs.","title":"hilbert_mean_power(self)"},{"location":"Plugins/Welch/","text":"Welch Is one of the methods for calculating the spectral density. welch_spectrum(self) Calculates the Welch spectrum. Adds the values to self.spectrum and self.spectrum_freqs . welch_mean_spectrum(self) Calculates the Welch spectrum and then takes the mean value across epochs. Adds the values to self.spectrum and self.spectrum_freqs","title":"Welch"},{"location":"Plugins/Welch/#welch","text":"Is one of the methods for calculating the spectral density.","title":"Welch"},{"location":"Plugins/Welch/#welch_spectrumself","text":"Calculates the Welch spectrum. Adds the values to self.spectrum and self.spectrum_freqs .","title":"welch_spectrum(self)"},{"location":"Plugins/Welch/#welch_mean_spectrumself","text":"Calculates the Welch spectrum and then takes the mean value across epochs. Adds the values to self.spectrum and self.spectrum_freqs","title":"welch_mean_spectrum(self)"}]}